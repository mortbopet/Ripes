#include "ripes_system.h"

/*
 * keyboardDualDisplay.c
 * Keyboard input demo with dual display output
 */

#define MATRIX_W        LED_MATRIX_0_WIDTH
#define MATRIX_H        LED_MATRIX_0_HEIGHT
#define CHAR_W          5
#define CHAR_H          7
#define COLOR_ON        0x00FF00
#define COLOR_OFF       0x000000
#define SEG_COUNT       4

// LED Matrix Font: 0-9, a-z (5x7 bitmap, 1 bit = 1 pixel)
static const unsigned char font[36][CHAR_H] = {
    // 0-9
    {0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E},  // 0
    {0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E},  // 1
    {0x0E, 0x11, 0x01, 0x06, 0x08, 0x10, 0x1F},  // 2
    {0x1F, 0x01, 0x02, 0x06, 0x01, 0x11, 0x0E},  // 3
    {0x11, 0x11, 0x11, 0x1F, 0x01, 0x01, 0x01},  // 4
    {0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E},  // 5
    {0x0E, 0x10, 0x10, 0x1E, 0x11, 0x11, 0x0E},  // 6
    {0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10},  // 7
    {0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E},  // 8
    {0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C},  // 9
    // A-Z
    {0x0E, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x00},  // a
    {0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E},  // b
    {0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E},  // c
    {0x1E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1E},  // d
    {0x1F, 0x10, 0x1E, 0x10, 0x10, 0x10, 0x1F},  // e
    {0x1F, 0x10, 0x1E, 0x10, 0x10, 0x10, 0x10},  // f
    {0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0F},  // g
    {0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11},  // h
    {0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E},  // i
    {0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x0E},  // j
    {0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11},  // k
    {0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F},  // l
    {0x11, 0x1B, 0x15, 0x11, 0x11, 0x11, 0x11},  // m
    {0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x11},  // n
    {0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E},  // o
    {0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10},  // p
    {0x0E, 0x11, 0x11, 0x11, 0x11, 0x0E, 0x01},  // q
    {0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11},  // r
    {0x0E, 0x11, 0x10, 0x0E, 0x01, 0x11, 0x0E},  // s
    {0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04},  // t
    {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E},  // u
    {0x11, 0x11, 0x11, 0x11, 0x11, 0x0A, 0x04},  // v
    {0x11, 0x11, 0x15, 0x15, 0x15, 0x15, 0x0A},  // w
    {0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11},  // x
    {0x11, 0x11, 0x11, 0x0A, 0x04, 0x04, 0x04},  // y
    {0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F}   // z
};

// 7-Segment Display Font: common-cathode encoding
static const unsigned char seg_digit[10] = {
    0x3F, 0x06, 0x5B, 0x4F, 0x66,
    0x6D, 0x7D, 0x07, 0x7F, 0x6F
};

static const unsigned char seg_alpha[26] = {
    0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71, 0x3D, 0x76, 0x06, 0x1E,
    0x76, 0x38, 0x37, 0x54, 0x3F, 0x73, 0x67, 0x50, 0x6D, 0x78,
    0x3E, 0x1C, 0x3E, 0x76, 0x6E, 0x5B
};

// Set single pixel on LED matrix
static inline void set_pixel(volatile unsigned int *led, int x, int y, unsigned int color) {
    if (x >= 0 && x < MATRIX_W && y >= 0 && y < MATRIX_H)
        *(led + y * MATRIX_W + x) = color;
}

// Draw character from font bitmap
static void draw_char_matrix(volatile unsigned int *led, int start_x, int start_y, int char_idx, unsigned int color) {
    const unsigned char *bitmap = font[char_idx];
    for (int dy = 0; dy < CHAR_H; dy++) {
        unsigned char row = bitmap[dy];
        for (int dx = 0; dx < CHAR_W; dx++)
            if (row & (1 << (CHAR_W - 1 - dx)))
                set_pixel(led, start_x + dx, start_y + dy, color);
    }
}

// Clear character area (5x7)
static void clear_char_area(volatile unsigned int *led, int start_x, int start_y) {
    for (int dy = 0; dy < CHAR_H; dy++)
        for (int dx = 0; dx < CHAR_W; dx++)
            set_pixel(led, start_x + dx, start_y + dy, COLOR_OFF);
}

// Convert ASCII to 7-segment code
static unsigned char encode_seg(unsigned char ch) {
    if (ch >= '0' && ch <= '9') return seg_digit[ch - '0'];
    if (ch >= 'A' && ch <= 'Z') return seg_alpha[ch - 'A'];
    if (ch >= 'a' && ch <= 'z') return seg_alpha[ch - 'a'];
    return 0;
}

// Convert ASCII to font index (0-35), -1 if unsupported
static int char_to_index(unsigned char ch) {
    if (ch >= '0' && ch <= '9') return ch - '0';
    if (ch >= 'A' && ch <= 'Z') return 10 + (ch - 'A');
    if (ch >= 'a' && ch <= 'z') return 10 + (ch - 'a');
    return -1;
}

int main() {
    volatile unsigned int *led = (volatile unsigned int *)LED_MATRIX_0_BASE;
    volatile unsigned int *seg = (volatile unsigned int *)SEVEN_SEGMENT_0_BASE;
    volatile unsigned int *kbd = (volatile unsigned int *)KEYBOARD_0_BASE;

    int prev_char_idx = -1;
    int center_x = (MATRIX_W - CHAR_W) / 2;
    int center_y = (MATRIX_H - CHAR_H) / 2;
    int seg_pos = 0;

    for (int i = 0; i < MATRIX_W * MATRIX_H; i++)
        *(led + i) = COLOR_OFF;

    for (int i = 0; i < SEG_COUNT; i++)
        *(seg + i) = 0;

    while (1) {
        if (*(kbd + 1) == 0)
            continue;

        unsigned char key = (unsigned char)(*kbd);
        int char_idx = char_to_index(key);
        unsigned char seg_code = encode_seg(key);

        if (char_idx >= 0 && char_idx < 36 && seg_code != 0) {
            if (prev_char_idx >= 0)
                clear_char_area(led, center_x, center_y);
            draw_char_matrix(led, center_x, center_y, char_idx, COLOR_ON);
            prev_char_idx = char_idx;

            *(seg + seg_pos) = seg_code;
            seg_pos++;
            if (seg_pos >= SEG_COUNT)
                seg_pos = 0;
        }
    }
    return 0;
}